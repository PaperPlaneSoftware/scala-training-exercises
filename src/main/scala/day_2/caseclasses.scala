package day_2

import java.time.LocalDate
import java.time.temporal.ChronoUnit

object caseclasses {
  // 1. Create case class representing an Author
  //    1. Author's have firstName, lastName and DOB
  //    2. Add a method to return an author's current age in years
  //    3. Add a static method to find the older of two Authors
  object Author {
    def older(a1: Author, a2: Author): Author = if(a1.dob isBefore a2.dob) a2 else a1
  }
  case class Author(firstName: String, lastName: String, dob: LocalDate) {
    def currentAge: Long = dob.until(LocalDate.now, ChronoUnit.YEARS)
  }

  // 2. Create case class representing a Book
  //    1. Book's have a title, datePublished, a rating and an author
  //    2. Add a method to return the age of the book in years
  //    3. Add a static method to find the more popular of two Books
  object Book {
    def mostPopular(b1: Book, b2: Book): Book = if(b1.rating < b2.rating) b2 else b1
  }
  case class Book(title: String, datePublished: LocalDate, rating: Int, author: Author) {
    def age: Long = datePublished.until(LocalDate.now, ChronoUnit.YEARS)
  }

  // 3. Create a case class that represents a Counter with two methods;
  //    increment and decrement
  //    1. Check that 2 Counters which are initialised to the same value are equal.
  //    2. If those counters are incremented and decremented the same number of
  //       times in different order are they still equal?
  case class Counter(value: Int) {
    def increment: Counter = Counter(value + 1)
    def decrement: Counter = Counter(value - 1)
  }
  val counter1 = Counter(0)
  val counter2 = Counter(0)
  assert(counter1 == counter2)

  val counter3 = counter1.increment.decrement.increment
  val counter4 = counter2.decrement.increment.increment
  assert(counter3 == counter4)

  // 4. What happens if we define our own companion object for a case class?
  //    1. Create a case class representing a Person with a first name, last name.
  //    2. Create a companion object with an alternate apply method which takes a
  //       name and splits it into first name and last name. i.e. "Tom Parslow"
  //       becomes "Tom", "Parslow".
  //    3. Does this custom companion object overwrite the companion object
  //       generated by Scala?
  object Person {
    def apply(name: String): Person = {
      val names = name.split(" ")
      if(names.length > 1)
        new Person(names(0), names(1))
      else if(names.length > 0) {
        new Person(names(0), "")
      } else {
        new Person("", "")
      }
    }
  }
  case class Person(firstName: String, lastName: String)

  // both apply functions are present on Person's companion object so the custom companion object does NOT overwrite
  // the one generated by Scala.
  val p1 = Person("Oliver", "Winks")
  val p2 = Person("Tom Parslow")

}
